{
  "hash": "f3e2731026def99f11f441f8a9d22be5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"The Cell Model of Chromatography\"\ndescription: \"Basic exploration of the cell model for chromatography\"\ncategories:\n    - Chemistry\n    - Simulation\nformat: html\ndate: 2025-11-10\nfreeze: true\njupyter: python3\n---\n\n## Chromatography\n\nChromatography is a process to seperate a mixture of substances into it's components.\nThis is done by transporting the mixture of substances through a stationary phase ('resistance') using a mobile phase ('driver').\nComponents that interact more strongly with the stationary phase will be held back longer than those that interact less, leading to separation.\n\nIt is used to e.g. determine the amount of impurities in a pharmaceutical product.\nOf the many different techniques of chromatography, HPLC (high-pressure liquid chromatography) and GC (gas chromatography) are the most prevalent.\n\n## Cell Model\n\nWe imagine the stationary (i.e. the column) and the mobile phase to consist of cells.\nEach cell of the stationary phase is in contact with one cell from the mobile phase.\nWe distribute the molecules between the stationary and mobile phase according to the equilibrium constant.\nWhen this is done, we move the mobile phase cells 'down one cell' such that they are in contact with the next\ncell of the stationary phase. Note: we use zero-based indexing for the cells (as does Python), so the first cell is cell 0.\n\n![Cell Model](./cell-model-img/cell-model.jpg)\n\n## Equilibrium\n\nThe molecules will partition between their bound and free state according to an equilibrium constant $K$.\nSince we will assume all the cells to be the same size (i.e. have the same volume) we can calculate with\namounts of molecules directly and do not need to bother with concentrations.\n\n$$K = \\frac{c_{bound}}{c_{free}} = \\frac{n_{bound}/V_{cell}}{n_{free}/V_{cell}} = \\frac{n_{bound}}{n_{free}}$$\n\nComputationally, it is much easier to reformulate the equilibrium constant as a fraction of bound molecules give the total number of molecules.\n\n$$f_{bound} = \\frac{K}{1 + K} \\cdot n_{total}$$\n\nThe number of free molecules is then simply $n_{free} = n_{total} - n_{bound}$.\n\n\n## Setup\n\n::: {#7e81d98a .cell quarto-private-1='{\"key\":\"ExecuteTime\",\"value\":{\"end_time\":\"2025-09-08T07:32:06.848601Z\",\"start_time\":\"2025-09-08T07:32:06.846302Z\"}}' execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n## Single Compound\n\n::: {#ba5b1a75 .cell execution_count=2}\n``` {.python .cell-code}\n# Define parameters\nn_cells = 100\nn_steps = 1_000\nn_molecules = 100_000\nK = 4\n\n# Reformat K to a fractional entity\nfrac_bound = K / (1 + K)\n\n# Initial state (zero everywhere)\nstationary_phase = np.zeros(n_cells)\nmobile_phase = np.zeros(n_cells + n_steps)\n\n# Loading of mobile phase in cell just before the stationary phase\nmobile_phase[n_cells] = n_molecules\n\nfor step in range(1, n_steps + 1):\n    # Equilibration\n    for cell in range(n_cells):\n        n_tot = stationary_phase[cell] + mobile_phase[cell + step]\n        n_bound = np.floor(n_tot * frac_bound)\n        n_free = n_tot - n_bound\n        stationary_phase[cell] = n_bound\n        mobile_phase[cell + step] = n_free\n\nplt.plot(mobile_phase)\nplt.xlim(0, n_steps)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-3-output-1.png){width=592 height=411}\n:::\n:::\n\n\n::: {#01e19bc8 .cell execution_count=3}\n``` {.python .cell-code}\nfrom scipy.stats import norm\n\nx = np.linspace(200, 800, 600)\ny = n_molecules * norm.pdf(x, loc=496, scale=45)\n\nplt.plot(mobile_phase, label=\"Simulation\")\nplt.plot(x, y, '--', label=\"Gaussian\")\nplt.xlim(0, n_steps)\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-4-output-1.png){width=592 height=411}\n:::\n:::\n\n\n### Observations\n\n- The simulation yields an almost symmetrical, gaussian-like peak.\n\n## Multiple Compounds\n\nExtending the simulation to multiple compounds is straightforward.\nAs all compounds are independent of each other, we can simply simulate each compound separately.\n\n::: {#f97cf914 .cell execution_count=4}\n``` {.python .cell-code}\n# Define parameters\nn_cells = 100\nn_steps = 1_100\nn_molecules = [100_000, 100_000, 100_000]\nK = [2, 4, 7]\n\n# Reformat K to a fractional entity\nfrac_bound = [k / (1 + k) for k in K]\n\n# Initial state (zero everywhere)\nstationary_phase = [np.zeros(n_cells) for _ in K]\nmobile_phase = [np.zeros(n_cells + n_steps) for _ in K]\n\n# Loading of mobile phase in cell just before the stationary phase\nfor compound, n_mol in enumerate(n_molecules):\n    mobile_phase[compound][n_cells] = n_mol\n\nfor step in range(1, n_steps + 1):\n    # Equilibration\n    for cell in range(n_cells):\n        for compound, frac in enumerate(frac_bound):\n            n_tot = stationary_phase[compound][cell] + mobile_phase[compound][cell + step]\n            n_bound = np.floor(n_tot * frac)\n            n_free = n_tot - n_bound\n            stationary_phase[compound][cell] = n_bound\n            mobile_phase[compound][cell + step] = n_free\n\nfor mp in mobile_phase:\n    plt.plot(mp)\nplt.xlim(0, n_steps)\nplt.legend([f'K={k}' for k in K])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-5-output-1.png){width=583 height=411}\n:::\n:::\n\n\n### Observations\n\n- Retention time increases with higher affinity to the stationary phase (column) - as we would expect.\n- Peak width increases with increasing retention time.\n- Peak height decreases with increasing retention time.\n- Overal peak area stays the same (= number of molecules; can be verified by summing over the mobile phases).\n\nFor compounds with higher affinity to the stationary phase, we need more cells to transport the compound out of the column because each mobile phase cell will contain fewer molecules than in the case of low-stationary-phase affinity.\n\n### Column Dead Volume\n\n::: {#277ea529 .cell execution_count=5}\n``` {.python .cell-code}\n# Define parameters\nn_cells = 100\nn_steps = 250\nn_molecules = [300_000, 70_000, 23_000]\nK = [1, 0.1, 1e-2]\n\n# Reformat K to a fractional entity\nfrac_bound = [k / (1 + k) for k in K]\n\n# Initial state (zero everywhere)\nstationary_phase = [np.zeros(n_cells) for _ in K]\nmobile_phase = [np.zeros(n_cells + n_steps) for _ in K]\n\n# Loading of mobile phase in cell just before the stationary phase\nfor compound, n_mol in enumerate(n_molecules):\n    mobile_phase[compound][n_cells] = n_mol\n\nfor step in range(1, n_steps + 1):\n    # Equilibration\n    for cell in range(n_cells):\n        for compound, frac in enumerate(frac_bound):\n            n_tot = stationary_phase[compound][cell] + mobile_phase[compound][cell + step]\n            n_bound = np.floor(n_tot * frac)\n            n_free = n_tot - n_bound\n            stationary_phase[compound][cell] = n_bound\n            mobile_phase[compound][cell + step] = n_free\n\nfor mp in mobile_phase:\n    plt.plot(mp)\nplt.vlines([99], 0, 1e4, colors=\"red\", linestyles=\"dashed\")\nplt.xlim(90, n_steps)\nplt.ylim(-5, 1e4)\nplt.legend([f'K={k}' for k in K])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-6-output-1.png){width=592 height=416}\n:::\n:::\n\n\n#### Observations\n\n- The lower the affinity to the stationary phase, the earlier the compound elutes.\n- Note that the peak height do not increase because we use fewer molecules for the low-affinity compounds.\n- There is a lower bound to the retention time, which is given by the number of cells in the column - 'dead volume'.\n\n## Decreasing Binding Affinity with Increasing Bound Molecules\n\nLet's suppose that the binding affinity of the stationary phase decreases with increasing number of bound molecules.\nInstead of using a 'hard stop' we will use a model where $K$ decreases exponentially with 'occupation'. \n\n::: {#88033f79 .cell execution_count=6}\n``` {.python .cell-code}\n# Define parameters\nn_cells = 100\nn_steps = 1_000\nn_molecules = 100_000\nK = 4\n\ndef frac_bound(n_bound):\n    # Reform K to a fractional entity - now also depending on loading\n    frac_bound = K / (np.exp(n_bound/30_000) + K)\n    return frac_bound\n\n# Initial state (zero everywhere)\nstationary_phase = np.zeros(n_cells)\nmobile_phase = np.zeros(n_cells + n_steps)\nmax_bound_molecules = np.zeros(n_steps + 1)\nsum_bound_molecules = np.zeros(n_steps + 1)\n\n# Loading of mobile phase in cell just before the stationary phase\nmobile_phase[n_cells] = n_molecules\n\nfor step in range(1, n_steps + 1):\n    # Record some information about the column\n    max_bound_molecules[step] = np.max(stationary_phase)\n    sum_bound_molecules[step] = np.sum(stationary_phase)\n    # Equilibration\n    for cell in range(n_cells):\n        n_bound_old = stationary_phase[cell]\n        n_tot = n_bound_old + mobile_phase[cell + step]\n        n_bound = np.floor(n_tot * frac_bound(n_bound_old))\n        n_free = n_tot - n_bound\n        stationary_phase[cell] = n_bound\n        mobile_phase[cell + step] = n_free\n\nplt.plot(mobile_phase)\nplt.xlim(0, n_steps)\nplt.show()\n\n# Let's also have a look at the maximum number of bound molecules\nplt.plot(max_bound_molecules, color=\"orange\")\nplt.plot(sum_bound_molecules, color=\"green\", linestyle=\"dashed\")\nplt.title(\"Number of Bound Molecules\")\nplt.legend([\"max n_bound\", \"sum n_bound\"])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-7-output-1.png){width=600 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-7-output-2.png){width=592 height=431}\n:::\n:::\n\n\n### Observations\n\n- Decreasing binding affinity leads to a tailing peak.\n- Due to the way the simulation is run the initial loading of the column is very, very high. Let's look at that in some more detail.\n\n::: {#09a98956 .cell execution_count=7}\n``` {.python .cell-code}\nplt.plot(max_bound_molecules, color=\"orange\")\nplt.plot(sum_bound_molecules, color=\"green\", linestyle=\"dashed\")\nplt.xlim(0, 100)\nplt.legend([\"max n_bound\", \"sum n_bound\"])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-8-output-1.png){width=604 height=411}\n:::\n:::\n\n\nWe see the oscillating behaviour at the beginning. First there are no bound molecules so $f_{bound}$ is high (0.8). In the next step the affinity is starkly decreased due to the high number of bound molecules. This is an issue in our model but does not affect the qualitative result. We can smooth this behaviour out a bit in a further iteration of the model.\n\n::: {#fd1d57d2 .cell execution_count=8}\n``` {.python .cell-code}\n# Define parameters\nn_cells = 100\nn_steps = 1_000\nn_molecules = 100_000\nK = 4\n\ndef frac_bound(n_bound):\n    # Reform K to a fractional entity - now also depending on loading\n    frac_bound = K / (np.exp(n_bound/30_000) + K)\n    return frac_bound\n\n# Initial state (zero everywhere)\nstationary_phase = np.zeros(n_cells)\nmobile_phase = np.zeros(n_cells + n_steps)\nmax_bound_molecules = np.zeros(n_steps + 1)\nsum_bound_molecules = np.zeros(n_steps + 1)\n\n# Loading of mobile phase in cell just before the stationary phase\nmobile_phase[n_cells] = n_molecules\n\nfor step in range(1, n_steps + 1):\n    # Record some information about the column\n    max_bound_molecules[step] = np.max(stationary_phase)\n    sum_bound_molecules[step] = np.sum(stationary_phase)\n    # Equilibration\n    for cell in range(n_cells):\n        n_bound = stationary_phase[cell]\n        n_tot = n_bound + mobile_phase[cell + step]\n        n_bound_new = np.floor(n_tot * frac_bound(n_bound))\n        # Interate on n_bound until consistent (give us some leeway +/- 1 molecule)\n        while abs(n_bound_new - n_bound) > 1:\n            n_bound = (n_bound_new + n_bound) / 2 # introduces some damping\n            n_bound_new = np.floor(n_tot * frac_bound(n_bound))\n        n_free = n_tot - n_bound\n        stationary_phase[cell] = n_bound\n        mobile_phase[cell + step] = n_free\n\nplt.plot(mobile_phase)\nplt.xlim(0, n_steps)\nplt.show()\n\n# Let's also have a look at the maximum number of bound molecules\nplt.plot(max_bound_molecules, color=\"orange\")\nplt.plot(sum_bound_molecules, color=\"green\", linestyle=\"dashed\")\nplt.legend([\"max n_bound\", \"sum n_bound\"])\nplt.title(\"Number of Bound Molecules\")\nplt.xlim(0, 100)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-9-output-1.png){width=592 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![](cell-model_files/figure-html/cell-9-output-2.png){width=604 height=431}\n:::\n:::\n\n\n",
    "supporting": [
      "cell-model_files"
    ],
    "filters": [],
    "includes": {}
  }
}